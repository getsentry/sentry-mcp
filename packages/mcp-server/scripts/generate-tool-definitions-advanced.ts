#!/usr/bin/env tsx
/**
 * Advanced tool definitions generator that preserves more type information.
 * This approach generates a TypeScript module with const assertions and type inference.
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import { zodToJsonSchema } from "zod-to-json-schema";
import { z } from "zod";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Import tools
const tools = await import("../src/tools/index.ts");

/**
 * Extract Zod schema type name if possible (for better documentation)
 */
function getZodTypeName(schema: z.ZodType): string {
  if (schema instanceof z.ZodString) return "string";
  if (schema instanceof z.ZodNumber) return "number";
  if (schema instanceof z.ZodBoolean) return "boolean";
  if (schema instanceof z.ZodArray) return "array";
  if (schema instanceof z.ZodObject) return "object";
  if (schema instanceof z.ZodEnum) return "enum";
  if (schema instanceof z.ZodOptional)
    return `${getZodTypeName(schema._def.innerType)} | undefined`;
  if (schema instanceof z.ZodNullable)
    return `${getZodTypeName(schema._def.innerType)} | null`;
  if (schema instanceof z.ZodUnion) return "union";
  return "unknown";
}

/**
 * Generate parameter interface for a tool
 */
function generateParameterInterface(
  toolName: string,
  inputSchema: Record<string, z.ZodType>,
): string {
  if (!inputSchema || Object.keys(inputSchema).length === 0) {
    return `export type ${toolName}Params = Record<string, never>;`;
  }

  const fields = Object.entries(inputSchema)
    .map(([key, schema]) => {
      const isOptional = schema instanceof z.ZodOptional;
      const typeName = getZodTypeName(schema);
      const description = (schema as any)._def?.description || "";

      return `  /** ${description} */\n  ${key}${isOptional ? "?" : ""}: ${typeName};`;
    })
    .join("\n");

  return `export interface ${toolName}Params {\n${fields}\n}`;
}

/**
 * Convert input schema to JSON Schema
 */
function convertInputSchemaToJsonSchema(inputSchema: Record<string, any>) {
  if (!inputSchema || Object.keys(inputSchema).length === 0) {
    return {};
  }

  const properties: Record<string, any> = {};
  const required: string[] = [];

  for (const [key, zodSchema] of Object.entries(inputSchema)) {
    const jsonSchema = zodToJsonSchema(zodSchema, {
      $refStrategy: "none",
    });
    properties[key] = jsonSchema;

    // Track required fields
    if (!(zodSchema instanceof z.ZodOptional)) {
      required.push(key);
    }
  }

  return { properties, required };
}

function generateAdvancedTypeScript() {
  const toolsDefault = tools.default;

  if (!toolsDefault || typeof toolsDefault !== "object") {
    throw new Error("Failed to import tools from src/tools/index.ts");
  }

  const toolEntries = Object.entries(toolsDefault);

  // Generate parameter types
  const parameterTypes = toolEntries
    .map(([key, tool]) => {
      const toolObj = tool as any;
      const pascalName = key.charAt(0).toUpperCase() + key.slice(1);
      return generateParameterInterface(pascalName, toolObj.inputSchema || {});
    })
    .join("\n\n");

  // Generate tool definitions
  const definitions = toolEntries.map(([key, tool]) => {
    const toolObj = tool as any;
    const { properties, required } = convertInputSchemaToJsonSchema(
      toolObj.inputSchema || {},
    );

    return {
      name: toolObj.name,
      description: toolObj.description,
      inputSchema: {
        type: "object",
        properties,
        required,
        additionalProperties: false,
      },
    };
  });

  // Generate the TypeScript module
  const code = `// Auto-generated file - DO NOT EDIT
// Generated by generate-tool-definitions-advanced.ts

import type { JsonSchema7 } from "json-schema";

/**
 * Parameter types for each tool
 */
${parameterTypes}

/**
 * Map of tool names to their parameter types
 */
export interface ToolParamsMap {
${toolEntries
  .map(([key, tool]) => {
    const toolObj = tool as any;
    const pascalName = key.charAt(0).toUpperCase() + key.slice(1);
    return `  "${toolObj.name}": ${pascalName}Params;`;
  })
  .join("\n")}
}

/**
 * Tool definition with full JSON Schema
 */
export interface ToolDefinition<TName extends keyof ToolParamsMap = keyof ToolParamsMap> {
  name: TName;
  description: string;
  inputSchema: JsonSchema7;
}

/**
 * All tool definitions with literal types
 */
export const TOOL_DEFINITIONS = ${JSON.stringify(definitions, null, 2)} as const;

/**
 * Helper to get typed tool definition
 */
export function getToolDefinition<TName extends keyof ToolParamsMap>(
  name: TName
): ToolDefinition<TName> | undefined {
  return TOOL_DEFINITIONS.find((tool) => tool.name === name) as any;
}

/**
 * Type guard to check if a value is a valid tool name
 */
export function isValidToolName(name: string): name is keyof ToolParamsMap {
  return TOOL_DEFINITIONS.some((tool) => tool.name === name);
}

/**
 * Get parameters type for a specific tool
 */
export type ToolParams<TName extends keyof ToolParamsMap> = ToolParamsMap[TName];

// Default export for compatibility
const toolDefinitions: ToolDefinition[] = [...TOOL_DEFINITIONS];
export default toolDefinitions;
`;

  return code;
}

async function main() {
  try {
    console.log("Generating advanced TypeScript tool definitions...");

    const code = generateAdvancedTypeScript();
    const outputPath = path.join(
      __dirname,
      "../src/toolDefinitions.generated.ts",
    );

    fs.writeFileSync(outputPath, code);

    console.log(`‚úÖ Generated advanced tool definitions`);
    console.log(`üìÑ Output: ${outputPath}`);

    // Format with prettier if available
    try {
      const { execSync } = await import("node:child_process");
      execSync(`npx prettier --write ${outputPath}`, { stdio: "inherit" });
    } catch {
      // Ignore if prettier is not available
    }
  } catch (error) {
    console.error("‚ùå Failed to generate tool definitions:", error);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
